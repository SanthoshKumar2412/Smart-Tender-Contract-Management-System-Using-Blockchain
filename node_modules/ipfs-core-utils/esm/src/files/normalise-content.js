import errCode from 'err-code';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import browserStreamToIt from 'browser-readablestream-to-it';
import blobToIt from 'blob-to-it';
import itPeekable from 'it-peekable';
import all from 'it-all';
import map from 'it-map';
import {
  isBytes,
  isReadableStream,
  isBlob
} from './utils.js';
export async function normaliseContent(input) {
  return toAsyncGenerator(input);
}
async function* toAsyncGenerator(input) {
  if (isBytes(input)) {
    yield toBytes(input);
    return;
  }
  if (typeof input === 'string' || input instanceof String) {
    yield toBytes(input.toString());
    return;
  }
  if (isBlob(input)) {
    yield* blobToIt(input);
    return;
  }
  if (isReadableStream(input)) {
    input = browserStreamToIt(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = itPeekable(input);
    const {value, done} = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      yield Uint8Array.from(await all(peekable));
      return;
    }
    if (isBytes(value) || typeof value === 'string' || value instanceof String) {
      yield* map(peekable, toBytes);
      return;
    }
  }
  throw errCode(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return uint8ArrayFromString(chunk.toString());
}